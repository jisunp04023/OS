# Chapter 06 교착상태

## 01 교착 상태의 개요

* dead lock
  - 다른 프로세스의 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태
  - starvation: OS가 잘못된 정책을 사용해 특정 프로세스의 작업이 지연되는 문제
  - deadlock: 정책상 잘못이 없어도 자연적으로 일어나는 문제. 강압적으로 해결해야 함

* 교착 상태 발생
  - 시스템 자원, 공유 변수(또는 파일), 응용 프로그램 등을 사용할 때 발생

* resource allocation graph (지원 할당 그래프)

  <img src = "https://user-images.githubusercontent.com/23165155/110080937-8ac78a80-7dce-11eb-941e-375f5f3d2f6b.png" width = "%50">
  
  - 프로세스가 어떤 자원을 사용 중이고 어떤 자원을 기다리고 있는지를 directional graph로 표현한 것
  - 프로세스: 원 / 자원: 사각형
  - multiple resource: 여러 프로세스가 하나의 자원을 동시에 사용

## 02 교착 상태 필요조건

* 이 중 단 하나라도 충족하지 않으면 교착상태가 발생하지 않음
  * mutual exclusion (상호 배제)
    - 한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이어야 함
  * non-preemption (비선점)
    - 한 프로세스가 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이어야 함
  * hold and wait (점유와 대기)
    - 프로세스가 어떤 자원을 할당받은 상태에서 다른자원을 기다리는 상태여야 함
  * circular wait (원형 대기)
    - 점유와 대기를 하는 프로세스 간의 관계가 원을 이루어야 함

## 03 교착 상태 해결 방법

* prevention (교착 상태 예방): 교착 상태 유발하는 네 가지 조건을 무력화
  - mutual exclusion prevention
    - 시스템 내 모든 상호배타적인 자원을 없애는 방법 (전부 공유자원으로 구현)
    - 현실적으로 불가능 (임계구역)
  - non-preemption prevention
    - 모든 자원을 뺏을 수 있도록(선점) 만드는 방법
    - 잠금 사용 불가해짐
    - 전부 선점할 수 있게 된다 해도 뺏는 우선순위를 결정하는 문제와 그에 따른 starvation 발생
    - aging도 불가. aging 하는 순간 선점의 의미 사라짐
  - hold and wait prevention
    - 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법 (all or nothing: 전부 점유하거나 모두 반납하거나)
    - 프로세스는 자신이 사용할 모든 자원을 알기 어려움
    - 당장 사용하지도 않을 자원을 선점해서 낭비가 심함
    - 많은 자원 사용하는 프로세스가 적은 자원 사용하는 애보다 불리해서 starvation 발생
    - 일괄 작업 방식으로 작동
  - circular wait prevention
    - 원형 이루지 못하도록 자원에 숫자 붙여서 큰 방향으로만 자원을 할당
    - 작업 진행에 유연성 떨어짐. 사용자 납득 불가
    - 자원의 번호는 어떻게 부여할 것인지 문제
    
  - 평가
    - 상호 배재/비선점 예방은 자원을 보호하기 위해 어렵고, 점유와 대기/원형 대기 예방은 작업 방식을 제한하고 자원을 낭비

* avoidance (교착 상태 회피): 교착 상태가 발생하지 않는 수준으로 자원을 할당
  - banker's algorithm: Available >= Expect인 경우(안정상태)가 하나 이상인 경우에 할당
  - 사용할 모든 자원을 미리 선언해야 함
  - 시스템 전체 자원의 수가 고정적이어야 함
  - 자원이 낭비됨 (불안정 상태라고 무조건 교착상태 아님에도 자원을 할당하지 않음)
  - 평가: 그래서 사용 안함

* detection (교착 상태 검출): 자원 할당 그래프를 사용하여 교착 상태를 발견
  - timeout을 이용한 detection (가벼운 교착상태 검출)
    - 타임아웃 걸릴 때까지 작업이 진행되지 않은 프로세스를 교착상태가 발생한 것으로 간주
    - 특별한 알고리즘 없어서 구현 쉬움
    - 다른 이유로 작업이 진행되지 못하던 프로세스가 강제 종료될 수 있음
    - 모든 시스템에 적용될 수 없음 (ex. 분산 데이터베이스)
  - resource allocation graph를 이용한 detection (무거운 교착상태 검출)
    - 사이클이 있으면 교착상태가 발생한 것으로 판단
    - 그래프 유지, 갱신, 검사 등 추가작업으로 오버헤드 발생
    
* recovery (교책 상태 회복): 교착 상태를 검출한 후 해결
  - 교착상태를 유발한 프로세스를 강제로 종료
    - 교착 상태 일으킨 모든 프로세스 동시에 종료
      - 다시 실행할 때는 기준에 따라 순차적으로 실행
    - 교착 상태 일으킨 프로세스 중 하나를 골라 순서대로 종료
      - 우선 순위 낮은 프로세스 먼저 종료
      - 작업 시간 짧은 프로세스 먼저 종료
      - 자원 많이 사용하는 프로세스 먼저 


