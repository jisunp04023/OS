# Chapter 04 CPU 스케줄링

## 01 스케줄링의 개요

* CPU scheduler (= process scheduler)
  - 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정
  - CPU와 시스템 자원을 어떻게 배정할지 결정

* 스케줄링의 단계
  * high level scheduling
    - 시스템 내의 전체 작업 수를 조절하는 것
    - = long-term scheduling = job scheduling
    - 어떤 작업을 시스템이 승인할지 거부할지를 결정 (= admission scheduling)
  * low level scheduling
    - 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
    - 아주 짧은 시간에 일어남 (= short-term scheduling)
  * middle level scheduling
    - 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는 것
    - 고수준 스케줄링과 저수준 스케줄링 사이에 일어남
    - suspend(중지)와 active(활성화)로 전체 시스템의 활성화된 프로세스 수를 조절
    - 일부를 suspend status로 옮겨(swap out) buffer의 역할을 함

* 스케줄링의 목적
  - 공평성: 자원 배정 과정에서 특정 프로세스가 배제되어서는 안됨
  - 효율성: 시스템 자원이 유휴 시간 없이 사용되도록 하고, 유휴 자원 사용하려는 프로세스에는 우선권 부여
  - 안정성: 우선순위 배정함으로써 시스템 자원 점유, 파괴하려는 프로세스로부터 자원을 보호
  - 확장성: 프로세스가 증가해도 시스템이 안정적으로 작동하도록, 자원이 늘어나는 경우에도 혜택이 반영되도록
  - 반응 시간 보장: 응답이 없는 경우 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 함
  - 무한 연기 방지: 특정 프로세스의 작업이 무한히 연기되어서는 안됨

## 02 스케줄링 시 고려 사항

- preemptive scheduling (선점형 스케줄링): '빼앗을 수 있음'
  - 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 OS가 강제로 빼앗을 수 있는 스케줄링 방식
  - 장점: 프로세스가 CPU 독점할 수 없어 대화형 시스템, 시분할 시스템에 적합
  - 단점: 문맥 교환의 오버헤드가 많음
  - 시분할 방식 스케줄러에 사용

- non-preemptive scheduling (비선점형 스케줄링): '빼앗을 수 없음'
  - 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
  - 장점: 스케줄러의 작업량이 적고 문맥 교환에 의한 오버헤드도 적음
  - 단점: 기다리는 프로세스가 많아 처리율이 떨어짐
  - 일괄 작업 장식 스케줄러에 사용

* 우선순위
  - 커널 프로세스 > 일반 프로세스 [명확]
  - 전면 프로세스 > 후면 프로세스 [명확]
  - 대화형 프로세스 > 일괄 처리 프로세스 [구분 불가한 경우도 有]
  - 입출력 집중 프로세스 > CPU 집중 프로세스 [구분 불가한 경우도 有]

## 03 다중 큐

- multiple queue: 프로세스를 효율적으로 관리하기 위해 큐를 여러 개 두어 관리
  - 준비 상태의 다중 큐
    - 우선순위에 따라 다중 큐 운영
  - 대기 상태의 다중 큐
    - 같은 입출력을 요구한 프로세스들을 모아 다중 큐 운영

## 04 스케줄링 알고리즘

<img src = "https://user-images.githubusercontent.com/23165155/109760631-5d45da00-7c32-11eb-9a21-7631745a20b0.PNG" width = "75%">

* FCFS(First Come First Service) scheduling
  - 준비 큐에 도착한 순서대로 CPU 할당. 큐 하나라 모든 프로세스의 우선순위가 동일함
  - 장점: 알고리즘이 단순하고 공평함
  - 단점: convoy effect(호위 효과)- 실행시간 긴 프로세스가 CPU 차지하면 다른 프로세스는 하염없이 기다려 효율성 떨어짐

* SJF(Shortest Job First) scheduling
  - 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU 할당
  - 장점: convoy effect를 완화하여 시스템 효율성을 높임
  - 단점
    - OS가 프로세스 종료 시간을 정확하게 예측하기 어려움
    - starvation: aging을 통해 완화

* HRN(Highest Response Ratio Next) scheduling
  - 대기시간과 CPU 사용 시간을 고려하여 우선순위를 결정
  - 우선순위

    <img src = "https://user-images.githubusercontent.com/23165155/109764043-56b96180-7c36-11eb-9d70-2f9066f1a877.PNG" width = "30%">
    
      - 대기시간 ↓↓, CPU 사용시간 ↑↑ -> 우선순위 ↑↑
  - 장점: starvation 완화
  - 단점: 여전히 공평성이 위배되어 많이 사용하지 않음

* RR(Round Robin) scheduling
  - 타임 슬라이스 동안 작업을 완료하지 못하면 준비 큐 맨 뒤(tail)로 가서 자기 차례 기다리는 방식 (우선순위X)
  - 장점: convoy effect 완화
  - 단점: 문맥 교환
    - 타임 슬라이스 큰 경우: FCFS 스케줄링과 다를 게 없어짐
    - 타임 슬라이스 작은 경우: 문맥 교환 너무 자주 일어나 시간 낭비, 성능 떨어짐

* SRT(Shortest Remaining Time) scheduling
  - 기본적으로 RR 사용, 남아 있는 작업 시간이 가장 적은 프로세스를 선택
  - 장점: 성능은 좋을 수 있음
  - 단점: 남은 시간을 주기적으로 계산, 문맥교환 등 추가 작업, 마찬가지로 OS가 프로세스 종료시간 예측 어렵고, starvation

* priority scheduling
  - 비선점형 방식과 선점형 방식에 모두 적용할 수 있음
    - (비선점형 방식) SJF scheduling: 작업 시간 짧은 프로세스에 높은 우선순위 부여
    - (비선점형 방식) HRN scheduling: 작업 시간 짧거나 대기 시간 긴 프로세스에 높은 우선순위 부여
    - (선점형 방식) SRT scheduling: 남은 시간이 짦은 프로세스에 높은 우선순위 부여
  - 고정 우선순위 알고리즘
    - 한 번 우선순위 부여받으면 고정됨. 변하는 시스템 상황 반영 못해 효율성 떨어짐
  - 변동 우선순위 알고리즘
    - 일정 시간마다 우선순위 변함. 시스템 복잡하지만 상황을 반영한 효율적 운영 가능
  - 장점: 우선순위가 시스템의 효율성보다 프로세스의 중요도에 따라 정해짐
  - 단점: 공평성 위배, starvation, 큐 순서를 우선순위에 따라 매번 바꿔야 해서 오버헤드 발생, 효율성 떨어짐

* multilevel queue scheduling
  - 우선순위에 따라 준비 큐를 여러 개 사용하는 방식. 고정형 우선순위. 상단 큐 모든 작업 끝나면 다음 큐의 작업 시작
  - 장점: 우선순위 높은 프로세스 먼저 작동, 우선순위에 따라 타임 슬라이스 조절해 효율 높일 수 있음
  - 단점: 우선순위가 높은 프로세스 때문에 우선순위 낮은 프로세스의 작업이 연기됨

* multilevel feedback queue scheduling
  - 각 단계의 큐에 RR 방식 사용, CPU 사용하고 난 프로세스는 우선순위 하나 낮은 큐의 tail로 들어감
  - 우선순위에 따라 타임 슬라이스 크기가 다름
    - 우선순위 높음-> 타임 슬라이스 크기 ↓↓
    - 우선순위 낮음-> 타임 슬라이스 크기 ↑↑
  - 장점: 우선순위 낮은 프로세스 실행이 연기되는 문제를 완화
